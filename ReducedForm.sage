def FindUnit(matrix,i_row,j_col):
    """
        Find a unit from the base ring in the given row or column.
    """
    
    #Check column for unit
    for j in range(j_col,matrix.dimensions()[1]):
        if (matrix[i_row][j]).is_unit():
            return [True, True, i_row, j]
    
    #Check row for unit
    for i in range(i_row,matrix.dimensions()[0]):
        if (matrix[i][j_col]).is_unit():
            return [True, False, i, j_col]
    
    #No unit found
    else:
        return [False, False, 0, 0]
        
        
def FindNonUnitIdeal(matrix, a, i_row, j_col):
    """
        Find a non-unit contained in the ideal generated by 'a' but not 
        contained in the ideal generated by 'a^2'. 
    """
    R = matrix[0][0].parent()
    
    Ideal = R.ideal(a)
    IdealSquared = R.ideal(a^2)
    
    #Check column for non-unit
    for j in range(j_col,matrix.dimensions()[1]):
        if matrix[i_row][j] != 0:
            if (matrix[i_row][j] in Ideal) and (matrix[i_row][j] not in IdealSquared):
                return [True, True, i_row, j]
    
    #Check row for non-unit
    for i in range(i_row,matrix.dimensions()[0]):
        if matrix[i_row][j] != 0:
            if (matrix[i][j_col] in Ideal) and (matrix[i][j_col] not in IdealSquared):
                return [True, False, i, j_col]
    
    #No unit found
    else:
        return [False, False, 0, 0]
        
def FindNonUnitIdealSquared(matrix, a, i_row, j_col):
    """
        Find a non-unit contained in the ideal generated by 'a^2'. 
    """
    R = matrix[0][0].parent()
    
    Ideal = R.ideal(a^2)
    
    #Check column for non-unit
    for j in range(j_col,matrix.dimensions()[1]):
        if (matrix[i_row][j] in Ideal) and (matrix[i_row][j] != 0):
            return [True, True, i_row, j]
    
    #Check row for non-unit
    for i in range(i_row,matrix.dimensions()[0]):
        if (matrix[i][j_col] in Ideal) and (matrix[i][j_col] != 0):
            return [True, False, i, j_col]
    
    #No unit found
    else:
        return [False, False, 0, 0]
        
        
def ReduceUnitColumn(matrix, i_row, j_col):
    """
        Reduce the column of a pivot position to 0.
    """
    lv = matrix[i_row][j_col]
    matrix[i_row] = [ m_ix / lv for m_ix in matrix[i_row] ]
    for j in range(matrix.dimensions()[0]):
        if j != i_row:
            lv = matrix[j][j_col]
            matrix[j] = [ jv - lv*rv for rv,jv in zip(matrix[i_row],matrix[j])]    
    
    return matrix
    
    
def MoveToEnd(matrix, i_row):
    """
        Move row of matrix to the end of the matrix.
    """
    if (i_row + 1) == matrix.dimensions()[0]:
        return matrix
    
    matrix = matrix.stack(matrix[i_row])
    matrix = matrix.delete_rows([i_row])
    
    return matrix
    
    
def ReduceNonUnitColumn(matrix, a, i_row, j_col):
    """
        Reduce a given matrix element to 'a' and then make entries above
        and below the matrix element to 0 if they are contained in the ideal
        generated by 'a'. 
        
        Note: This function only works over Z/p^l Z for some prime p. It must be
        that the element to reduce is equal to a*r for r a unit.
    """
    
    if (a.is_unit()) or (a == 0):
        raise ValueError("{} must be a non-zero non-unit".format(a))
    
    #Create the ideal
    lv = matrix[i_row][j_col]
    R = lv.parent()
    Ideal = R.ideal(a)
    
    #Make sure desired pivot position is in the ideal
    if lv not in Ideal:
        raise ValueError("Matrix element not contained in the ideal generated by {}".format(a))

    order = R.order()
    BasePrime = (order).prime_factors()[0]
    
    #Compute the unit r such that lv = r*a 
    temp_lv = Integer(lv)
    inv = temp_lv/(a)
    inv = R(1/inv)
    
    matrix[i_row] = [ m_ix * inv for m_ix in matrix[i_row] ]
    lv = matrix[i_row][j_col]
    
    for i in range(matrix.dimensions()[0]):
        if i == i_row:
            continue
        if (matrix[i][j_col] != 0) and (matrix[i][j_col] in Ideal): #Kept this for in case of reducing above
            row_lv = matrix[i][j_col]
            coef = 1
            while row_lv + coef*lv != 0:
                coef += 1
            
            matrix[i] = [ x + coef*m_ix for m_ix,x in zip(matrix[i_row],matrix[i])]
    
    return matrix
    

def ReducedForm(matrix):
    """
        Given a matrix over Z/p^3 Z for some prime p, put in upper triangular form
        where the diagonal consists of 1 followed by the prime p and p^2.
        
        Arguments:
            
            -matrix : a matrix over Z/p^3 Z
            
        Returns:
        
            -matrix : an upper triangular matrix
    """
    
    if not matrix: return
    
    BaseRing = matrix[0][0].parent()
    
    if len((BaseRing.order()).prime_factors()) > 1:
        raise ValueError("Matrix must be from ring over Z/p^3 Z for some prime p")
        
    BasePrime = (BaseRing.order()).prime_factors()[0]
    BasePower = (BaseRing.order()).log(BasePrime)
    
    if BasePower > 3:
        raise ValueError("not implemented for l = {}".format(BasePower))
    
    numRow, numCol = matrix.dimensions()
    Sorted = False #Diagonal sorted or not
    
    i_row = 0
    j_col = 0
    
    entry_count = 1 #Count how many rows gone through
    SortUnits = True 
    
    #Move the unit col/row to the left of the matrix and reduce
    while SortUnits:
        
        #Find a unit in the row or column of the first pivot position
        UnitVec = FindUnit(matrix,i_row,j_col)
        
        #If unit found, move to pivot position and reduce
        if UnitVec[0]:
            if UnitVec[1]:
                matrix.swap_columns(UnitVec[2],UnitVec[3])
            else:
                matrix.swap_rows(UnitVec[2],UnitVec[3])
            
            matrix = ReduceUnitColumn(matrix, i_row,j_col)
            i_row += 1
            j_col += 1
        else:
            matrix = MoveToEnd(matrix, i_row)
        
        entry_count += 1
        SortUnits = (entry_count <= numRow) and (entry_count <= numCol)

    #Check if the diagonal is full of 1's
    if (i_row >= numRow) or (j_col >= numCol):
        Sorted = True
    
    #At this point the submatrix that is not sorted only has non-units
    
    #Fill the diagonal with p and remove below
    if (not Sorted) and (BasePower >= 2):

        SortIdealP = True

        entry_count = i_row + 1 #Start from the first non-unit position
        while SortIdealP:

            NonUnitVec = FindNonUnitIdeal(matrix, BasePrime, i_row, j_col)

            if NonUnitVec[0]:
                if NonUnitVec[1]:
                    matrix.swap_columns(NonUnitVec[2],NonUnitVec[3])
                else:
                    matrix.swap_rows(NonUnitVec[2],NonUnitVec[3])

                matrix = ReduceNonUnitColumn(matrix, BasePrime, i_row, j_col)
                i_row += 1
                j_col += 1
            else:
                matrix = MoveToEnd(matrix, i_row)

            entry_count += 1 #Stop sorting once get through all the rows of the submatrix
            SortIdealP = (entry_count <= numRow) and (entry_count <= numCol)
            
        if (i_row >= numRow) or (j_col >= numCol):
            Sorted = True
            
        #At this point the submatrix that is not sorted consists of either 0s or 
        #non-units from the ideal (p^2)
        if (not Sorted) and (BasePower == 3):

            SortIdealPSquared = True
            entry_count = i_row + 1 #Start from the first row consisting of elements not in (p)

            while SortIdealPSquared:
                NonUnitVec = FindNonUnitIdealSquared(matrix, BasePrime, i_row, j_col)

                if NonUnitVec[0]:
                    if NonUnitVec[1]:
                        matrix.swap_columns(NonUnitVec[2],NonUnitVec[3])
                    else:
                        matrix.swap_rows(NonUnitVec[2],NonUnitVec[3])

                    matrix = ReduceNonUnitColumn(matrix, BasePrime^2, i_row, j_col)
                    i_row += 1
                    j_col += 1
                else:
                    matrix = MoveToEnd(matrix, i_row)

                entry_count += 1 #Stop sorting once get through all the rows of the submatrix
                SortIdealPSquared = (entry_count <= numRow) and (entry_count <= numCol)
                

    #At this point, the matrix is completely sorted so just need to check for 
    #empty rows or columns
    
    #If there aren't pivot positions to the last row, then must have a row of 0s
    #and we can remove them
    while i_row < numRow:
        last_row = matrix.dimensions()[0] - 1
        matrix = matrix.delete_rows([last_row])
        i_row += 1
    
    #Check the last columns for 0 columns to delete
    while j_col < numCol:
        del_col = True
        for i in range(matrix.dimensions()[0]):
            if matrix[i][j_col] != 0:
                del_col = False
                break
        
        if del_col:
            matrix = matrix.delete_columns([j_col])
            numCol = numCol - 1
        else:
            j_col += 1
    
    return matrix